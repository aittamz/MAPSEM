<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rete Relazionale – MAPSEM</title>
  <style>
    :root{
      color-scheme: light dark;

      --ui-bg: #ffffff;
      --ui-border: #e5e7eb;
      --ui-text: #111827;
      --ui-text-muted: #6b7280;
      --ui-hover: rgba(0,0,0,.04);
      --ui-active: rgba(0,0,0,.06);
    }

    body{
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--ui-bg);
      color: var(--ui-text);
    }

    header{
      position: sticky;
      top: 0;
      z-index: 10;

      backdrop-filter: blur(8px);
      background: var(--ui-bg);
      border-bottom: 1px solid var(--ui-border);

      padding: 10px 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      color: var(--ui-text);
    }

    header a,
    header button{
      border: 1px solid var(--ui-border);
      background: var(--ui-bg);
      padding: 6px 10px;
      border-radius: 10px;

      color: var(--ui-text);
      text-decoration: none;
      cursor: pointer;
      font-size: 14px;
    }

    header a:hover,
    header button:hover{
      background: var(--ui-hover);
    }

    #wrap{
      height: calc(100vh - 54px);
      width: 100%;
      overflow: hidden;
      touch-action: none;
      background: var(--ui-bg);

      user-select: none;
      -webkit-user-select: none;
      cursor: grab;
    }
    #wrap:active{ cursor: grabbing; }

    #wrap svg{
      width: 100%;
      height: 100%;
      display: block;
      background: var(--ui-bg);
    }

    .hint{ margin-left: auto; opacity: .75; font-size: 13px; color: var(--ui-text-muted); }

    /* --- LEGENDA --- */
    .legend{
      position: fixed;
      right: 1rem;
      bottom: 1rem;
      z-index: 9999;

      background: var(--ui-bg);
      border: 1px solid var(--ui-border);
      border-radius: 14px;
      padding: 10px 12px;

      box-shadow: 0 6px 16px rgba(0,0,0,.10);
      font-size: 14px;
      line-height: 1.35;
      min-width: 210px;

      color: var(--ui-text);
      pointer-events: auto; /* IMPORTANTISSIMO: la legenda riceve click */
    }
    .legend, .legend *{ color: var(--ui-text); }

    .legend-title{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;

      font-weight: 650;
      margin-bottom: 8px;
    }
    .legend-title small{
      color: var(--ui-text-muted);
      font-weight: 500;
    }

    .legend-item{
      display: flex;
      align-items: center;
      gap: 10px;

      margin-top: 6px;
      padding: 6px 8px;
      border-radius: 10px;

      cursor: pointer;
      border: 1px solid transparent;
    }
    .legend-item:hover{ background: var(--ui-hover); }
    .legend-item.active{
      border-color: var(--ui-border);
      background: var(--ui-active);
    }

    .legend-color{
      width: 18px;
      height: 18px;
      border-radius: 4px;
      flex-shrink: 0;
    }

    .legend-actions{
      margin-top: 10px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .legend-actions button{
      border: 1px solid var(--ui-border);
      background: var(--ui-bg);
      padding: 6px 10px;
      border-radius: 10px;

      cursor: pointer;
      font-size: 13px;
      color: var(--ui-text);
    }
    .legend-actions button:hover{ background: var(--ui-hover); }
  </style>
</head>

<body>
  <header>
    <a href="index.html">← Indice</a>
    <button id="reset">Reset</button>
    <span class="hint">Drag = sposta · Rotella/trackpad = zoom (Shift = turbo)</span>
  </header>

  <div id="wrap" aria-label="SVG viewer"></div>

  <div class="legend" id="legend">
    <div class="legend-title">
      <span>Legenda</span>
      <small>clicca un ruolo</small>
    </div>

    <div class="legend-item" data-color="#e6a6ff"><span class="legend-color" style="background:#e6a6ff"></span><span>compositore</span></div>
    <div class="legend-item" data-color="#7fd300"><span class="legend-color" style="background:#7fd300"></span><span>editore</span></div>
    <div class="legend-item" data-color="#00c4ff"><span class="legend-color" style="background:#00c4ff"></span><span>paroliere</span></div>
    <div class="legend-item" data-color="#4f4a45"><span class="legend-color" style="background:#4f4a45"></span><span>esecutore</span></div>
    <div class="legend-item" data-color="#ff8a00"><span class="legend-color" style="background:#ff8a00"></span><span>traduttore</span></div>
    <div class="legend-item" data-color="#ff4f87"><span class="legend-color" style="background:#ff4f87"></span><span>arrangiatore</span></div>
    <div class="legend-item" data-color="#00c389"><span class="legend-color" style="background:#00c389"></span><span>dedicatario</span></div>
    <div class="legend-item" data-color="#d7b8b2"><span class="legend-color" style="background:#d7b8b2"></span><span>direttore_orchestra</span></div>
    <div class="legend-item" data-color="#c9c9c9"><span class="legend-color" style="background:#c9c9c9"></span><span>riduttore</span></div>

    <div class="legend-actions">
      <button id="legend-showall" type="button">Mostra tutto</button>
    </div>
  </div>

  <script>
    const SVG_FILE = "mattia_test_2.svg";
    const wrap = document.getElementById("wrap");
    const resetBtn = document.getElementById("reset");

    // riferimenti SVG (per la legenda)
    let svgRef = null;

    // Camera
    let scale = 1, panX = 0, panY = 0;

    // Drag
    let isPanning = false, dragged = false;
    let lastX = 0, lastY = 0;
    let vx = 0, vy = 0;
    let inertiaRaf = null;

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function applyTransform(viewportG){
      viewportG.setAttribute("transform", `translate(${panX} ${panY}) scale(${scale})`);
    }
    function fitToView(svg, viewportG){
      if (!svg.getAttribute("viewBox")) {
        const bb = viewportG.getBBox();
        svg.setAttribute("viewBox", `${bb.x} ${bb.y} ${bb.width} ${bb.height}`);
      }
      scale = 1; panX = 0; panY = 0;
      applyTransform(viewportG);
    }

    function stopInertia(){
      if (inertiaRaf) cancelAnimationFrame(inertiaRaf);
      inertiaRaf = null;
    }
    function startInertia(viewportG){
      stopInertia();
      const step = () => {
        vx *= 0.90; vy *= 0.90;
        panX += vx;  panY += vy;
        applyTransform(viewportG);
        if (Math.abs(vx) + Math.abs(vy) > 0.25) inertiaRaf = requestAnimationFrame(step);
        else stopInertia();
      };
      inertiaRaf = requestAnimationFrame(step);
    }

    // ---- Filtro archi per colore (robusto per SVG Gephi) ----
    function hexToRgbString(hex){
      const h = hex.replace("#","").trim();
      const full = h.length === 3 ? h.split("").map(c => c+c).join("") : h;
      const n = parseInt(full, 16);
      const r = (n >> 16) & 255;
      const g = (n >> 8) & 255;
      const b = n & 255;
      return `rgb(${r}, ${g}, ${b})`;
    }
    function normalizeRgb(str){
      const s = String(str || "").trim().toLowerCase();
      const m = s.match(/rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/i);
      if (m) return `rgb(${+m[1]}, ${+m[2]}, ${+m[3]})`;
      return s;
    }

    function getEdgeElements(svg){
      // 1) struttura tipica Gephi: #edges contiene path/line
      const grp = svg.querySelector("#edges");
      if (grp) {
        const els = grp.querySelectorAll("path, line, polyline");
        if (els.length) return Array.from(els);
      }
      // 2) alternative: elementi con class "edge"
      const byClass = svg.querySelectorAll("path.edge, line.edge, polyline.edge, g.edge path, g.edge line, g.edge polyline");
      if (byClass.length) return Array.from(byClass);
      // 3) fallback: tutto ciò che ha stroke e NON è dentro #nodes
      const all = Array.from(svg.querySelectorAll("path, line, polyline"));
      return all.filter(el => !el.closest("#nodes"));
    }

    function getNodeGroups(svg){
      // per “sfumare” i nodi (non filtrarli): #nodes oppure g.node
      const grp = svg.querySelector("#nodes");
      if (grp) return Array.from(grp.children).filter(x => x instanceof SVGElement);
      const gnodes = svg.querySelectorAll("g.node");
      return gnodes.length ? Array.from(gnodes) : [];
    }

    function edgeStrokeColor(el){
      const attr = el.getAttribute("stroke");
      if (attr && attr !== "none") return normalizeRgb(attr);
      return normalizeRgb(getComputedStyle(el).stroke);
    }

    function showAll(){
      if (!svgRef) return;
      // reset opacità su edges e nodes (qualunque struttura)
      getEdgeElements(svgRef).forEach(e => e.style.opacity = "");
      getNodeGroups(svgRef).forEach(n => n.style.opacity = "");
    }

    function filterEdgesByColor(hexColor){
      if (!svgRef) return;
      const target = normalizeRgb(hexToRgbString(hexColor));

      const edges = getEdgeElements(svgRef);
      const nodes = getNodeGroups(svgRef);

      // nodi: visibili ma discreti
      nodes.forEach(n => n.style.opacity = "0.18");

      // archi: fade + highlight target
      edges.forEach(e => e.style.opacity = "0.04");
      edges.forEach(e => {
        if (edgeStrokeColor(e) === target) e.style.opacity = "1";
      });
    }

    // ---- Legenda click (attaccata SUBITO, non dipende dal loadSvg) ----
    const legendItems = Array.from(document.querySelectorAll(".legend-item"));
    const showAllBtn = document.getElementById("legend-showall");

    function setActive(item){
      legendItems.forEach(x => x.classList.remove("active"));
      if (item) item.classList.add("active");
    }

    legendItems.forEach(item => {
      item.addEventListener("click", () => {
        const color = item.getAttribute("data-color");
        const isActive = item.classList.contains("active");

        if (isActive) {
          setActive(null);
          showAll();
          return;
        }
        setActive(item);
        filterEdgesByColor(color);
      });
    });

    showAllBtn.addEventListener("click", () => {
      setActive(null);
      showAll();
    });

    // ---- Caricamento SVG + pan/zoom ----
    async function loadSvg(){
      const res = await fetch(SVG_FILE, { cache: "no-store" });
      const text = await res.text();
      wrap.innerHTML = text;

      const svg = wrap.querySelector("svg");
      if (!svg) throw new Error("SVG non trovato nel file.");
      svgRef = svg;

      svg.removeAttribute("width");
      svg.removeAttribute("height");
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      let viewportG = svg.querySelector("#viewport");
      if (!viewportG) {
        viewportG = document.createElementNS("http://www.w3.org/2000/svg", "g");
        viewportG.setAttribute("id", "viewport");
        while (svg.firstChild) viewportG.appendChild(svg.firstChild);
        svg.appendChild(viewportG);
      }

      fitToView(svg, viewportG);

      // PAN
      wrap.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        isPanning = true;
        dragged = false;
        stopInertia();
        wrap.setPointerCapture(e.pointerId);
        lastX = e.clientX; lastY = e.clientY;
        vx = 0; vy = 0;
      });

      wrap.addEventListener("pointermove", (e) => {
        if (!isPanning) return;

        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;

        if (!dragged && Math.hypot(dx, dy) > 2) dragged = true;

        panX += dx; panY += dy;
        vx = vx * 0.6 + dx * 0.4;
        vy = vy * 0.6 + dy * 0.4;

        lastX = e.clientX; lastY = e.clientY;
        applyTransform(viewportG);
      });

      wrap.addEventListener("pointerup", () => {
        if (!isPanning) return;
        isPanning = false;
        if (dragged) startInertia(viewportG);
      });

      wrap.addEventListener("pointercancel", () => {
        isPanning = false;
        stopInertia();
      });

      wrap.addEventListener("click", (e) => {
        if (dragged) {
          e.preventDefault();
          e.stopPropagation();
          dragged = false;
        }
      }, true);

      // ZOOM
      wrap.addEventListener("wheel", (e) => {
        e.preventDefault();

        const rect = wrap.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;

        const prevScale = scale;
        const delta = -e.deltaY;

        const base = e.shiftKey ? 1.18 : 1.06;
        const zoomFactor = delta > 0 ? base : 1 / base;

        scale = clamp(scale * zoomFactor, 0.05, 60);

        panX = cx - (cx - panX) * (scale / prevScale);
        panY = cy - (cy - panY) * (scale / prevScale);

        applyTransform(viewportG);
      }, { passive: false });

      // RESET
      resetBtn.addEventListener("click", () => fitToView(svg, viewportG));
    }

    loadSvg().catch(err => {
      wrap.innerHTML = `<p style="padding:12px">Errore: ${err.message}</p>`;
      console.error(err);
    });
  </script>
</body>
</html>
